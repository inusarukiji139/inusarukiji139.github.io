---
title: "オブジェクト指向の用語整理"
date: 2023-07-30
categories: ["OOP"]
tags: ["OOP"]
---
オブジェクト指向はソフトウェア開発を楽にする設計技術です。

しかしオブジェクト指向で使われる用語はとても多く、初学者の理解を難しくしています。

本稿では、オブジェクト指向で使われる用語を整理します。

## 歴史

オブジェクト指向が必要となったのは、従来の方法では限界があったからです。

これまでのプログラミング技術が、何を達成し、何が限界だったかを順に辿ります。

## 構造化以前

### | 高級言語

コンピュータの黎明期には、記述が難しい機械語・アセンブリ語が使われていました。

高級言語の登場で、人間に親しみやすい表現形式でプログラムが書けるようになりました。

### | GOTO文

処理を任意の位置へと移動させるための制御文です。

`C`

```c
int main() {
  int v = 0;
  
  goto B;
  
  A: printf("a");
     if (v > 2) goto C;
  B: printf("b");
     v += 1;
     goto A;
  C: printf("c");
     if (v < 4) goto B;
}
```

条件分岐や繰り返しのような制御を可能にしましたが、

使いすぎるとプログラムの流れが分からなくなるという欠点がありました。

## 構造化

GOTO文は論理構造を複雑にしてしまうため、使うことを禁止し、

順次・条件分岐・繰り返しの三構造だけで表現することが提唱されました。

論理構造が明確で、わかりやすいプログラムを作成できるようになりました。

また、サブルーチン(≒関数)の独立性を強化することも提唱されました。

コードの再利用性が向上し、プログラムを保守しやすくなりました。

### | 順次

指定した手順に従って順番に処理を進めていくこと。

### | 条件分岐

指定した条件によってプログラムを分岐させること。

### | 繰り返し

指定した手順を繰り返し処理すること。

### | サブルーチン(≒関数)

何らかの入力(input)を受け取り、それを処理して何らかの出力(output)をする部品。

独立しており、呼び出し側が参照している変数には影響がありません。

## オブジェクト指向

構造化は、処理の流れの改善を達成しましたが、以下の課題が見えてきました。

・グローバル変数がいつ変更されるかわからない

・関数が大規模開発において再利用しにくい

そこで関連する変数と関数を一個の部品とし、部品をグルーピングすることで解決しました。

ソフトウェアが解決すべき課題のことを問題領域と言います。

問題領域を単純化する技法として、分割統治と抽象化が提唱されました。

### | 分割統治(divide and conquer algorithm)

問題が大きなまま解決を試みるのではなく、問題を小さな単位に分割し、

単純化することで個別に解決しながら、全体の大きな問題を解決していく技法です。

#### 方法：カプセル化

データと処理をひとまとめにし、1つのモジュールとして定義することです。

#### データ隠蔽(data hiding)

カプセル化を維持する手法のひとつで、外部からフィールドを直接操作できないようにすることです。

カプセル化されたモジュールが勝手に利用されることを避けるためにデータ遮断を行います。

#### アクセサメソッド

画面表示やDB保存などの目的でフィールドにアクセスしたい場合は使用します。実装しなくてもよいです。

```c
# アクセス修飾子をprivateにすることで外部からフィールド操作を禁じる
# フィールドにアクセスしたい場合はgetter, setterをつかう
```

### | 抽象化(abstraction)

複雑な問題を単純な問題になるまで分解すると、膨大な数になり、かえって複雑になります。

そこで問題の本質となる共通部分を抽出し、グループ化する技法です。

#### 方法１：継承

サブクラス(子クラス)がスーパークラス(親クラス)から属性や振る舞いを受け継ぐことです。

クラス同士の結合度が高まり，柔軟性が低下するので、基本的に利用するべきではありません。

#### ダックタイピング

動的型付け言語で採用されている手法です。

#### 方法２：ポリモーフィズム

インスタンスを抽象化し、共通の型であつかいます。

#### 情報隠蔽(information hiding)

抽象化の効果を維持する手法で、公開部分と非公開部分を区別してあつかうことです。

抽象化によって無視した筈のモジュールが勝手に利用されることを避けるために情報遮蔽を行います。

公開部分は、**インターフェース**や**抽象クラス**として公開します。

非公開部分は、パッケージ・アクセス修飾子を使って不適切なアクセスを制御します。

```c
# インターフェースを継承したクラスは、必ず抽象メソッドをoverrideする
# インターフェースからインスタンスを生成するには、Factoryパターンをつかう
```